#include "Graph.h"
#include <iostream>
using namespace std;

int main()
{
    // Constructor  
    cout << ". . . Constructor test . . ." << endl;
    cout << "Construct a graph g." << endl; 
    Graph g;
    cout << endl << ". . . empty() test1 . . ." << endl;
    // Empty
    cout << "Is g empty? " << g.empty() << endl;
    cout << endl << ". . . addVertex(...) test . . ." << endl;
    // Adding Vertices
    cout << "Adding vertices A-E." << endl;
    g.addVertex("A", 10);
    g.addVertex("B", 20);
    g.addVertex("C", 30);
    g.addVertex("D", 40);
    g.addVertex("E", 50);
    cout << "Show the graph: ";
    g.printGraph();
    cout << "Attempt to add vertex duplicates A-E." << endl;
    g.addVertex("A", 34);
    g.addVertex("B", 55);
    g.addVertex("C", 71);
    g.addVertex("D", 23);
    g.addVertex("E", 69);
    cout << "Show the graph: ";
    g.printGraph();
    cout << endl << ". . . empty() test2 . . ." << endl;
    // Empty
    cout << "Is g empty? " << g.empty() << endl;
    cout << endl << ". . . addEdge(...) test . . ." << endl;
    // Adding edges
    cout << "Adding edge A-B." << endl; 
    g.addEdge("A", "B", 75);
    cout << "Show the graph." << endl;
    g.printGraph();
    cout << "Adding edge A-Z." << endl;
    g.addEdge("A", "Z", 980);
    cout << "Show the graph." << endl;
    g.printGraph();
    cout << "Adding edge Z-A." << endl;
    g.addEdge("Z", "A", 980);
    cout << "Show the graph." << endl;
    g.printGraph();
    cout << "Adding edges A-C, A-E, B-C, C-D." << endl;
    g.addEdge("A", "C", 20);
    g.addEdge("A", "E", 320);
    g.addEdge("B", "C", 25);
    g.addEdge("C", "D", 35);
    cout << "Show the graph." << endl;
    g.printGraph();
    cout << "Try adding duplicate edges with higher weights." << endl;
    g.addEdge("C", "A", 30);
    g.addEdge("E", "A", 400);
    g.addEdge("B", "C", 44);
    g.addEdge("C", "D", 233);
    cout << "Displaying g." << endl;
    g.printGraph();
    cout << "Try adding duplicate edges with lower weights." << endl;
    g.addEdge("C", "A", 3);
    g.addEdge("E", "A", 4);
    g.addEdge("B", "C", 4);
    g.addEdge("C", "D", 2);
    cout << "Displaying g." << endl;
    g.printGraph();
    // Writing to a file
    cout << endl << ". . . writeToFile(...) test . . ." << endl;
    cout << "Writing graph to file." << endl;
    g.writeToFile("test.graphs\\written.txt");
    // Reading from a file
    cout << endl << ". . . readFromFile(...) test . . ." << endl;
    cout << "Reading in a graph from file." << endl;
    g.readFromFile("test.graphs\\foograph.txt");
    cout << "Displaying g." << endl;
    g.printGraph();
    cout << "Reading in a graph from invalid file." << endl;
    g.readFromFile("test.graphs\\junkgraph.txt");
    cout << "Displaying g." << endl;
    g.printGraph();
    cout << "Reading in a graph from the file written to." << endl;
    g.readFromFile("test.graphs\\written.txt");
    // Minimum spanning tree
    cout << endl << ". . . minWeightComponent(...) test . . ." << endl;
    cout << "Find minWeightComponents." << endl;
    cout << "For E: ";
    g.minWeightComponent("E");
    cout << "For B: "; 
    g.minWeightComponent("B");
    cout << "For C: ";
    g.minWeightComponent("C");
    cout << "For D: ";
    g.minWeightComponent("D");
    cout << "For A: ";
    g.minWeightComponent("A");
    cout << "Construct a graph g2." << endl;
    Graph g2;
    cout << "Adding vertices A-J." << endl;
    g2.addVertex("A", 1);
    g2.addVertex("B", 1);
    g2.addVertex("C", 1);
    g2.addVertex("D", 1);
    g2.addVertex("E", 1);
    g2.addVertex("F", 1);
    g2.addVertex("G", 1);
    g2.addVertex("H", 1);
    g2.addVertex("I", 1);
    g2.addVertex("J", 1);
    cout << "Adding duplicate vertices A-J." << endl;
    g2.addVertex("A", 4);
    g2.addVertex("B", 9);
    g2.addVertex("C", 3);
    g2.addVertex("D", 7);
    g2.addVertex("E", 2);
    g2.addVertex("F", 6);
    g2.addVertex("G", 1);
    g2.addVertex("H", 1);
    g2.addVertex("I", 8);
    g2.addVertex("J", 3);
    cout << "Adding edges A-D, A-C, D-C, D-F, C-F, C-E, F-E, C-B, B-A, A-G,"
                << "B-G, B-E, F-J, E-J, I-J, H-J, G-E, G-H, G-I, E-I, H-I."
                << endl;
    g2.addEdge("A", "D", 6.1);
    g2.addEdge("A", "C", 4.1);
    g2.addEdge("D", "C", 3.1);
    g2.addEdge("D", "F", 9.1);
    g2.addEdge("C", "F", 9.1);
    g2.addEdge("C", "E", 9.1);
    g2.addEdge("F", "E", 8.1);
    g2.addEdge("C", "B", 2.1);
    g2.addEdge("B", "A", 2.1);
    g2.addEdge("A", "G", 9.1);
    g2.addEdge("B", "G", 9.1);
    g2.addEdge("B", "E", 8.1);
    g2.addEdge("F", "J", 18.1);
    g2.addEdge("E", "J", 10.1);
    g2.addEdge("I", "J", 3.1);
    g2.addEdge("H", "J", 4.1);
    g2.addEdge("G", "E", 7.1);
    g2.addEdge("G", "H", 4.1);
    g2.addEdge("G", "I", 5.1);
    g2.addEdge("E", "I", 9.1);
    g2.addEdge("H", "I", 1.1);
    cout << "Displaying g2." << endl;
    g2.printGraph();
    cout << "Find minWeightComponents." << endl;
    cout << "For C: ";
    g2.minWeightComponent("C");
    cout << "For I: ";
    g2.minWeightComponent("E");
    g2.minWeightComponent("ABC");    
    // Breadth-first search
    cout << endl << ". . . BFS(...) . . ." << endl;
    cout << "BFS from C for D" << endl;
    cout << g2.BFS("C", "D") << endl;
    cout << "BFS from ABCDEF for D" << endl;
    cout << g2.BFS("ABCDEF", "D") << endl;
    cout << "BFS from C for DEFGHJKL." << endl;
    cout << g2.BFS("C", "DEFGHJKL") << endl;
    cout << "BFS from ABCDEF for DEFGHJKL" << endl;
    cout << g2.BFS("ABCDEF", "DEFGHJKL") << endl;
    cout << "BFS from J for A" << endl;
    cout << g2.BFS("J", "A") << endl;
    cout << "BFS from E for D" << endl;
    cout << g2.BFS("E", "D") << endl;
    cout << "BFS from C for I" << endl;
    cout << g2.BFS("C", "I") << endl;
    cout << "BFS from H for A" << endl;
    cout << g2.BFS("H", "A") << endl;
    // Depth-first search
    cout << endl <<  ". . . DFS(...) . . ." << endl;
    cout << "DFS from C for D" << endl;
    cout << g2.DFS("C", "D") << endl;
    cout << "DFS from ABCDEF for D" << endl;
    cout << g2.DFS("ABCDEF", "D") << endl;
    cout << "DFS from C for DEFGHJKL." << endl;
    cout << g2.DFS("C", "DEFGHJKL") << endl;
    cout << "DFS from ABCDEF for DEFGHJKL" << endl;
    cout << g2.DFS("ABCDEF", "DEFGHJKL") << endl;
    cout << "DFS from J for A" << endl;
    cout << g2.DFS("J", "A") << endl;
    cout << "DFS from E for D" << endl;
    cout << g2.DFS("E", "D") << endl;
    cout << "DFS from C for I" << endl;
    cout << g2.DFS("C", "I") << endl;
    cout << "DFS from H for A" << endl;
    cout << g2.DFS("H", "A") << endl;
    // Closeness
    cout << endl << ". . . CLOSENESS(...) . . ." << endl;
    cout << "closeness() from C to D" << endl;
    cout <<  g2.closeness("C", "D") << endl;
    cout << "closeness() from D to H" << endl;
    cout << g2.closeness("D", "H") << endl;
    cout << "closeness() from E to Ewok" << endl;
    cout << g2.closeness("E", "Ewok") << endl;
    cout << "closeness() from Ewok to E" << endl;
    cout << g2.closeness("Ewok", "E") << endl;
    cout << "closeness() from E to E" << endl;
    cout << g2.closeness("E", "E") << endl;
    cout << "closeness from Ewok to Ewok" << endl;
    cout << g2.closeness("Ewok", "Ewok") << endl;
    cout << "closeness from D to G" << endl; 
    cout << g2.closeness("D", "G") << endl;
    // Number of connected components
    cout << endl << ". . . NUMCONNECTEDCOMPONENTS() . . ." << endl;
    g.printGraph();
    cout << "How many components are there?" << g.numConnectedComponents()
        << endl;
    Graph gsw;
    gsw.readFromFile("test.graphs\\foograph.txt");
    gsw.printGraph();
    cout << "How many components are there?" << gsw.numConnectedComponents()
        << endl;
    // Whether a graph is a tree
    cout << endl << ". . . ISTREE() . . ." << endl;
    g.printGraph();
    cout << "Is it a tree?" << endl;
    cout << g.tree() << endl;
    gsw.printGraph();
    cout << "Is it a tree?" << endl;
    cout << gsw.tree() << endl;
    Graph gTree;
    gTree.addVertex("ROOT", 3);
    gTree.addVertex("BRANCH1", 4);
    gTree.addVertex("BRANCH2", 1);
    gTree.addVertex("BRANCH3", 5);
    gTree.addVertex("BRANCH4", 6);
    gTree.addEdge("ROOT", "BRANCH1", 1);
    gTree.addEdge("ROOT", "BRANCH2", 1);
    gTree.addEdge("ROOT", "BRANCH3", 1);
    gTree.printGraph();
    cout << "Is it a tree?" << endl;
    cout << gTree.tree() << endl;
    gTree.addEdge("ROOT", "BRANCH4", 1);
    gTree.printGraph();
    cout << "Is it now a tree?" << endl;
    cout << gTree.tree() << endl;
    // Bipartite-ness
    cout << endl << ". . . PARTITIONABLE() . . ." << endl;
    Graph gPart;
    gPart.addVertex("aragorn", 1);
    gPart.addVertex("bilbo", 1);
    gPart.addVertex("castamir", 1);
    gPart.addVertex("durin", 1);
    gPart.addVertex("elbereth", 1);
    gPart.addVertex("fangorn", 1);
    gPart.addEdge("aragorn", "durin", 1);
    gPart.addEdge("aragorn", "elbereth", 1);
    gPart.addEdge("durin", "castamir", 1);
    gPart.addEdge("bilbo", "elbereth", 1);
    gPart.addEdge("bilbo", "fangorn", 1);
    gPart.addEdge("castamir", "elbereth", 1);
    gPart.printGraph();
    cout << "Is it partitionable? " << gPart.partitionable() << endl;
    gTree.printGraph();
    cout << "Is it partitionable? " << gTree.partitionable() << endl;
    gsw.printGraph();
    cout << "Is it partionable? " << gsw.partitionable() << endl;
    // Subgraph Test
    cout << endl << ". . . IS-SUBGRAPH(...) . . ." << endl;
    Graph gSet;
    gSet.addVertex("Gondor", 14);
    gSet.addVertex("Shire", 4);
    gSet.addVertex("Isengard", 2314);
    gSet.addVertex("Dead Marshes", 3);
    gSet.addEdge("Gondor", "Dead Marshes", 12);
    gSet.addEdge("Isengard", "Shire", 34);
    gSet.addEdge("Gondor", "Isengard", 22);
    gSet.addEdge("Shire", "Dead Marshes", 71);
    cout << "Inspect a set." << endl;
    gSet.printGraph();
    Graph gSubSet;
    gSubSet.addVertex("Shire", 4);
    gSubSet.addVertex("Dead Marshes", 3);
    gSubSet.addVertex("Gondor", 14);
    gSubSet.addEdge("Shire", "Isengard", 34);
    gSubSet.addEdge("Dead Marshes", "Gondor", 12);
    gSubSet.addEdge("Shire", "Dead Marshes", 71);
    cout << "Inspect a tentative subset." << endl;
    gSubSet.printGraph();
    cout << "Is the subset a true subset? " << gSet.isSubGraph(gSubSet) << endl;
    Graph emptyG;
    cout << "Inspect an empty graph." << endl;
    emptyG.printGraph();
    cout << "Is the empty set a subset of the set? " << gSet.isSubGraph(emptyG)
        << endl; 
    // Finding target value path
    cout << endl << ". . . CLOSEVALPATH(...) . . ." << endl;
    Graph g3;
    g3.addVertex("a", .1);
    g3.addVertex("b", .4);
    g3.addVertex("c", .2);
    g3.addVertex("d", .2);
    g3.addEdge("a", "b", .1);
    g3.addEdge("a", "c", .1);
    g3.addEdge("c", "d", .1);
    g3.addVertex("e", .1);
    g3.addVertex("f", .1);
    g3.addVertex("g", .1);
    g3.addVertex("h", .1);
    g3.addVertex("i", .1);
    g3.addEdge("e", "f", .1);
    g3.addEdge("f", "g", .1);
    g3.addEdge("g", "h", .1);
    g3.addEdge("h", "i", .1);
    g3.printGraph();
    cout << "Find path with value closest to 9.9." << endl;
    g3.printPathCloseVal(9.9);
    cout << "Find path with value closest to .5" << endl;
    g3.printPathCloseVal(.5);
    cout << "Find path with value closest to .2" << endl;
    g3.printPathCloseVal(.2);
    cout << "A path is a sequence of edges. A lone vertex is not a path."
            << endl;
    g3.addVertex("j", 0.05);
    g3.addVertex("k", 0.05);
    g3.addEdge("j", "k", 1);
    g3.printGraph();
    cout << "Find path with value closest to .1." << endl;
    g3.printPathCloseVal(.1);
    cout << "Find path with value closest to 0." << endl;
    g3.printPathCloseVal(0);
    cout << "Find path with value closest to -1." << endl;
    g3.printPathCloseVal(-1);
    return 0;   
}
